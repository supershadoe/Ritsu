`use strict`;
/* Adopted from https://gist.github.com/devsnek/77275f6e3f810a9545440931ed314dc1 */

import { Env } from ".";

const VERIFY_ALGO = "NODE-ED25519";

/**
 * To convert a string which has raw bytes encoded as hexadecimal numbers
 * into an Uint8Array.
 * 
 * @param hex The bytes in hex provided as a string
 * @returns Uint8Array
 */
function hex2bin(hex: string): Uint8Array {
    return new Uint8Array(
        hex.match(/[A-Za-z0-9]{2}/g)?.map(
            (byte) => parseInt(byte, 16)
        ) ?? []
    );
}

/**
 * Creates an instance of CryptoKey using SubtleCrypto module exposed by
 * Cloudflare workers.
 * 
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto}
 * 
 * @param pubKey The Public key generated by Discord for the app.
 * @returns A promise for the CryptoKey instance created from the public key.
 */
export function importPubKey(pubKey: string): Promise<CryptoKey> {
    return crypto.subtle.importKey(
        "raw",
        hex2bin(pubKey),
        {
            name: VERIFY_ALGO,
            namedCurve: VERIFY_ALGO
        },
        true,
        ["verify"]
    );
}

/**
 * - To verify every request received to validate if the request is truly from
 * Discord or not.
 * - Validating the requests are mandatory as Discord would stop sending POST
 * requests if validation isn't done.
 *
 * @see {@link https://discord.com/developers/docs/interactions/receiving-and-responding#security-and-authorization}
 * 
 * @param key An instance of CryptoKey created from the app's public key
 * for verification.
 * @param signature The signature of the payload.
 * @param timestamp Timestamp at which the payland was signed.
 * @param body Body of the payload.
 * @returns Whether it is a verified message or not.
 */
export function verify(
    key: CryptoKey,
    signature: string,
    timestamp: string,
    body: string
): Promise<boolean> {
    return crypto.subtle.verify(
        VERIFY_ALGO,
        key,
        hex2bin(signature),
        (new TextEncoder()).encode(timestamp + body)
    );
}

/**
 * Middleware to check for existence of signature and timestamp in a payload
 * that was received.
 * 
 * @param request The request that was received.
 * @param _args The env and ctx that was passed by Cloudflare.
 * @returns A response if the request is invalid.
 */
export async function checkForSigAndTS(
    request: Request, ..._args: [Env, ExecutionContext]
): Promise<Response | undefined> {
    const signature = request.headers.get("X-Signature-ED25519");
    const timestamp = request.headers.get("X-Signature-Timestamp");
    if( ! ( signature && timestamp) ) {
        return new Response(
            "Missing signature and timestamp for verification",
            { status: 401 }
        );
    }
}

/**
 * Middleware to verify the signature of an interaction sent by Discord.
 * 
 * @param request The request that was received.
 * @param env Cloudflare secrets and KV added via wranger/dashboard.
 * @param _ The unused ExecutionContext obj sent by Cloudflare.
 * @returns A response if the request is invalid.
 */
export async function verifySig(
    request: Request, env: Env, _: ExecutionContext,
    _body: {body?: string}
): Promise<Response | undefined> {
    const pubKey = await importPubKey(env.RITSU_APP_PUB_KEY);
    const signature = <string> request.headers.get("X-Signature-ED25519");
    const timestamp = <string> request.headers.get("X-Signature-Timestamp");
    _body.body = await request.text();
    if (! await verify(pubKey, signature, timestamp, _body.body) ) {
        return new Response(
            "Received a request with invalid signature", { status: 401 }
        );
    }
}
